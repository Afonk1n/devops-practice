## Git — мини-шпаргалка под собес

### 1. Базовые сущности

- **Репозиторий (repo)** — папка с кодом + скрытая директория `.git` со всей историей.
- **Коммит (commit)** — «снимок» состояния файлов + сообщение.
- **Ветка (branch)** — линия разработки (например, `main`, `develop`, `feature/...`).
- **Удалённый репозиторий (remote)** — копия на сервере (GitHub, GitLab и т.д.), обычно `origin`.

### 2. Частые команды

```bash
git status
```
- показывает текущее состояние:
  - какие файлы изменены;
  - какие добавлены в staging;
  - на какой ветке ты сейчас.

```bash
git init
```
- делает из текущей папки новый git-репозиторий (создаёт `.git`).
- на Windows через WSL иногда бывают ошибки прав на смонтированных дисках (`/mnt/d/...`) — это нормально для учебного примера, можно инициализировать репо либо:
  - через Git for Windows (Git Bash/GUI) непосредственно в `D:\DevOpsPractice`;
  - либо создать тренировочный репозиторий целиком в домашней директории Linux: `mkdir ~/git-demo && cd ~/git-demo && git init`.

```bash
git add <file>
git add .
```
- добавляет изменения в **staging area** (подготовка к коммиту).
- `git add .` — добавить все изменения в текущей директории.

```bash
git commit -m "Сообщение"
```
- создаёт новый коммит со всеми изменениями из staging.

```bash
git log --oneline
```
- краткая история коммитов (хеш + сообщение).

```bash
git checkout -b feature/ci-demo
```
- создаёт новую ветку `feature/ci-demo` и сразу на неё переключается.

```bash
git branch
```
- показывает список локальных веток, звёздочкой отмечена текущая.

```bash
git remote add origin <URL>
```
- добавляет удалённый репозиторий по адресу `<URL>` (например, GitHub).

```bash
git push -u origin main
```
- отправляет локальную ветку `main` на удалённый `origin` и связывает их.

### 3. Типичный рабочий цикл разработчика

1. **Клонирование репозитория**:
   ```bash
   git clone <URL>
   cd <папка-проекта>
   ```
2. **Создание ветки для задачи**:
   ```bash
   git checkout -b feature/some-task
   ```
3. **Работа с кодом**:
   - правишь файлы;
   - проверяешь изменения:
     ```bash
     git status
     git diff
     ```
4. **Подготовка и коммит**:
   ```bash
   git add .
   git commit -m "Implement some task"
   ```
5. **Публикация ветки и открытие PR**:
   ```bash
   git push -u origin feature/some-task
   ```
   Дальше на GitHub/GitLab открываешь Pull/Merge Request.

После ревью и зелёного CI:
- ветку мержат в `main`;
- CI/CD может автоматически выкатить изменения.

### 4. Как это описать на собесе

- «С Git работаю на базовом уровне: `status`, `add`, `commit`, `branch`, `checkout`, `push`. Привык создавать отдельные ветки под задачи (`feature/...`) и открывать Pull Request на ревью.»
- «Понимаю связку Git ↔ CI: разработчик пушит изменения в ветку, а GitHub Actions или GitLab CI автоматически запускают сборку/тесты/сборку Docker-образа.»
- «Работал как с командной строкой (Git Bash/терминал), так и с Git-клиентами/интерфейсом GitHub.»


